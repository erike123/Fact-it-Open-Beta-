/**
 * Vulnerability Hunter Orchestrator
 * Coordinates monitoring, analysis, and reporting
 */

import { monitorTwitter, TweetResult, DEFAULT_VULN_KEYWORDS } from './monitors/twitter-monitor';
import {
  monitorGitHub,
  GitHubResult,
  DEFAULT_GITHUB_KEYWORDS,
} from './monitors/github-monitor';
import { analyzeRepository, RepoAnalysisResult } from './analyzer/repo-analyzer';

export interface VulnHunterConfig {
  twitter?: {
    bearerToken: string;
    enabled: boolean;
  };
  github?: {
    token: string;
    enabled: boolean;
  };
  keywords?: string[];
}

export interface VulnerabilityDiscovery {
  id: string;
  timestamp: number;
  source: {
    platform: 'twitter' | 'github';
    url: string;
    author: string;
    content: string;
  };
  githubUrls: string[];
  analysis?: RepoAnalysisResult;
  severity?: 'critical' | 'high' | 'medium' | 'low' | 'unknown';
  status: 'discovered' | 'analyzing' | 'analyzed' | 'error';
}

class VulnerabilityHunterOrchestrator {
  private discoveries: Map<string, VulnerabilityDiscovery> = new Map();
  private isRunning = false;

  /**
   * Start monitoring for vulnerabilities
   */
  async startMonitoring(config: VulnHunterConfig): Promise<VulnerabilityDiscovery[]> {
    if (this.isRunning) {
      console.warn('[Vuln Hunter] Already running');
      return [];
    }

    this.isRunning = true;
    console.info('[Vuln Hunter] Starting vulnerability monitoring...');

    const newDiscoveries: VulnerabilityDiscovery[] = [];

    try {
      // Monitor Twitter
      if (config.twitter?.enabled && config.twitter.bearerToken) {
        const tweets = await monitorTwitter({
          bearerToken: config.twitter.bearerToken,
          keywords: config.keywords || DEFAULT_VULN_KEYWORDS,
          maxResults: 50,
        });

        for (const tweet of tweets) {
          if (tweet.githubUrls && tweet.githubUrls.length > 0) {
            const discovery = this.createDiscoveryFromTweet(tweet);
            newDiscoveries.push(discovery);
            this.discoveries.set(discovery.id, discovery);
          }
        }
      }

      // Monitor GitHub
      if (config.github?.enabled && config.github.token) {
        const results = await monitorGitHub({
          token: config.github.token,
          keywords: config.keywords || DEFAULT_GITHUB_KEYWORDS,
          maxResults: 30,
        });

        for (const result of results) {
          const discovery = this.createDiscoveryFromGitHub(result);
          newDiscoveries.push(discovery);
          this.discoveries.set(discovery.id, discovery);
        }
      }

      console.info(`[Vuln Hunter] Found ${newDiscoveries.length} new discoveries`);

      // Analyze repositories for top discoveries
      await this.analyzeTopDiscoveries(config, 5); // Analyze top 5

      return newDiscoveries;
    } catch (error) {
      console.error('[Vuln Hunter] Error during monitoring:', error);
      return newDiscoveries;
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Analyze a specific repository
   */
  async analyzeDiscovery(
    discoveryId: string,
    githubToken: string
  ): Promise<VulnerabilityDiscovery | null> {
    const discovery = this.discoveries.get(discoveryId);
    if (!discovery) {
      console.error('[Vuln Hunter] Discovery not found:', discoveryId);
      return null;
    }

    if (discovery.githubUrls.length === 0) {
      console.warn('[Vuln Hunter] No GitHub URLs to analyze');
      return discovery;
    }

    console.info(`[Vuln Hunter] Analyzing discovery ${discoveryId}...`);

    // Update status
    discovery.status = 'analyzing';
    this.discoveries.set(discoveryId, discovery);

    try {
      // Analyze the first GitHub URL
      const repoUrl = discovery.githubUrls[0];
      const analysis = await analyzeRepository(repoUrl, githubToken);

      if (analysis) {
        discovery.analysis = analysis;
        discovery.severity = this.calculateSeverity(discovery, analysis);
        discovery.status = 'analyzed';
      } else {
        discovery.status = 'error';
      }

      this.discoveries.set(discoveryId, discovery);
      return discovery;
    } catch (error) {
      console.error('[Vuln Hunter] Error analyzing discovery:', error);
      discovery.status = 'error';
      this.discoveries.set(discoveryId, discovery);
      return discovery;
    }
  }

  /**
   * Get all discoveries
   */
  getDiscoveries(): VulnerabilityDiscovery[] {
    return Array.from(this.discoveries.values()).sort((a, b) => b.timestamp - a.timestamp);
  }

  /**
   * Get discovery by ID
   */
  getDiscovery(id: string): VulnerabilityDiscovery | null {
    return this.discoveries.get(id) || null;
  }

  /**
   * Clear all discoveries
   */
  clearDiscoveries(): void {
    this.discoveries.clear();
  }

  /**
   * Create discovery from tweet
   */
  private createDiscoveryFromTweet(tweet: TweetResult): VulnerabilityDiscovery {
    return {
      id: `twitter-${tweet.id}`,
      timestamp: new Date(tweet.createdAt).getTime(),
      source: {
        platform: 'twitter',
        url: tweet.url,
        author: tweet.author,
        content: tweet.text,
      },
      githubUrls: tweet.githubUrls || [],
      status: 'discovered',
    };
  }

  /**
   * Create discovery from GitHub result
   */
  private createDiscoveryFromGitHub(result: GitHubResult): VulnerabilityDiscovery {
    return {
      id: `github-${result.id}`,
      timestamp: new Date(result.createdAt).getTime(),
      source: {
        platform: 'github',
        url: result.url,
        author: result.author,
        content: `${result.title}\n\n${result.body}`,
      },
      githubUrls: [result.repositoryUrl],
      severity: result.severity as any,
      status: 'discovered',
    };
  }

  /**
   * Analyze top discoveries automatically
   */
  private async analyzeTopDiscoveries(config: VulnHunterConfig, count: number): Promise<void> {
    if (!config.github?.token) return;

    const discoveries = Array.from(this.discoveries.values())
      .filter((d) => d.status === 'discovered' && d.githubUrls.length > 0)
      .slice(0, count);

    console.info(`[Vuln Hunter] Auto-analyzing top ${discoveries.length} discoveries...`);

    for (const discovery of discoveries) {
      await this.analyzeDiscovery(discovery.id, config.github.token);
    }
  }

  /**
   * Calculate severity based on analysis
   */
  private calculateSeverity(
    discovery: VulnerabilityDiscovery,
    analysis: RepoAnalysisResult
  ): 'critical' | 'high' | 'medium' | 'low' | 'unknown' {
    // If severity already set from GitHub labels, use it
    if (discovery.severity && discovery.severity !== 'unknown') {
      return discovery.severity;
    }

    // Calculate based on analysis
    let score = 0;

    // Vulnerable dependencies
    if (analysis.vulnerableDependencies.length > 0) {
      score += analysis.vulnerableDependencies.length * 2;

      // Check for critical vulnerabilities
      const hasCritical = analysis.vulnerableDependencies.some((dep) =>
        dep.vulnerabilities.some((v) => v.severity === 'critical')
      );
      if (hasCritical) score += 5;
    }

    // Security.md presence
    if (analysis.securityMd) {
      score += 1; // Good sign (security-conscious project)
    } else {
      score += 2; // Bad sign (no security policy)
    }

    // Popular project (more impact if vulnerable)
    if (analysis.stars > 1000) score += 2;
    if (analysis.stars > 10000) score += 3;

    // Recent activity (actively maintained)
    const lastCommitAge = Date.now() - new Date(analysis.lastCommit).getTime();
    const daysOld = lastCommitAge / (1000 * 60 * 60 * 24);
    if (daysOld > 365) score += 2; // Unmaintained

    // Severity mapping
    if (score >= 10) return 'critical';
    if (score >= 7) return 'high';
    if (score >= 4) return 'medium';
    if (score >= 2) return 'low';
    return 'unknown';
  }
}

// Singleton instance
export const vulnHunter = new VulnerabilityHunterOrchestrator();
