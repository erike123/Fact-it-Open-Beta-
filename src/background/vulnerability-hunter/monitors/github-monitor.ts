/**
 * GitHub API Monitor
 * Searches GitHub issues, commits, and discussions for vulnerability disclosures
 */

export interface GitHubConfig {
  token: string;
  keywords: string[];
  maxResults?: number;
}

export interface GitHubResult {
  type: 'issue' | 'commit' | 'code';
  id: string;
  title: string;
  body: string;
  author: string;
  repositoryUrl: string;
  repositoryName: string;
  url: string;
  createdAt: string;
  state?: 'open' | 'closed';
  labels?: string[];
  severity?: string;
}

/**
 * Monitor GitHub for vulnerability disclosures
 */
export async function monitorGitHub(config: GitHubConfig): Promise<GitHubResult[]> {
  if (!config.token) {
    console.warn('[GitHub Monitor] No token provided, skipping');
    return [];
  }

  console.info('[GitHub Monitor] Searching GitHub for vulnerabilities...');

  const results: GitHubResult[] = [];

  try {
    // Search issues
    const issues = await searchGitHubIssues(config);
    results.push(...issues);

    // Search code (for SECURITY.md, vulnerability reports)
    const codeResults = await searchGitHubCode(config);
    results.push(...codeResults);

    console.info(`[GitHub Monitor] Found ${results.length} results`);
    return results;
  } catch (error) {
    console.error('[GitHub Monitor] Error:', error);
    return [];
  }
}

/**
 * Search GitHub issues for vulnerabilities
 */
async function searchGitHubIssues(config: GitHubConfig): Promise<GitHubResult[]> {
  const query = buildGitHubQuery(config.keywords, 'issue');
  const results: GitHubResult[] = [];

  try {
    const response = await fetch(
      `https://api.github.com/search/issues?${new URLSearchParams({
        q: query,
        sort: 'created',
        order: 'desc',
        per_page: String(config.maxResults || 30),
      })}`,
      {
        headers: {
          Authorization: `token ${config.token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      console.error('[GitHub Monitor] Issues API error:', response.status);
      return [];
    }

    const data = await response.json();

    for (const issue of data.items || []) {
      results.push({
        type: 'issue',
        id: String(issue.id),
        title: issue.title,
        body: issue.body || '',
        author: issue.user?.login || 'unknown',
        repositoryUrl: issue.repository_url.replace('api.github.com/repos/', 'github.com/'),
        repositoryName: extractRepoName(issue.repository_url),
        url: issue.html_url,
        createdAt: issue.created_at,
        state: issue.state,
        labels: issue.labels?.map((l: any) => l.name) || [],
        severity: extractSeverityFromLabels(issue.labels || []),
      });
    }

    console.info(`[GitHub Monitor] Found ${results.length} issues`);
    return results;
  } catch (error) {
    console.error('[GitHub Monitor] Error searching issues:', error);
    return [];
  }
}

/**
 * Search GitHub code for security-related files
 */
async function searchGitHubCode(config: GitHubConfig): Promise<GitHubResult[]> {
  // Search for SECURITY.md files that mention vulnerabilities
  const query = 'filename:SECURITY.md vulnerability OR CVE OR exploit';
  const results: GitHubResult[] = [];

  try {
    const response = await fetch(
      `https://api.github.com/search/code?${new URLSearchParams({
        q: query,
        sort: 'indexed',
        order: 'desc',
        per_page: String(Math.min(config.maxResults || 20, 20)), // Max 20 for code search
      })}`,
      {
        headers: {
          Authorization: `token ${config.token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      console.error('[GitHub Monitor] Code API error:', response.status);
      return [];
    }

    const data = await response.json();

    for (const item of data.items || []) {
      results.push({
        type: 'code',
        id: item.sha,
        title: `${item.repository.full_name}/${item.path}`,
        body: `Security documentation found: ${item.path}`,
        author: item.repository.owner.login,
        repositoryUrl: item.repository.html_url,
        repositoryName: item.repository.full_name,
        url: item.html_url,
        createdAt: new Date().toISOString(), // API doesn't provide this for code search
      });
    }

    console.info(`[GitHub Monitor] Found ${results.length} security files`);
    return results;
  } catch (error) {
    console.error('[GitHub Monitor] Error searching code:', error);
    return [];
  }
}

/**
 * Build GitHub search query
 */
function buildGitHubQuery(keywords: string[], type: 'issue' | 'code'): string {
  const keywordQuery = keywords.map((kw) => `"${kw}"`).join(' OR ');

  if (type === 'issue') {
    return `${keywordQuery} is:issue state:open created:>2024-01-01`;
  } else {
    return keywordQuery;
  }
}

/**
 * Extract repository name from API URL
 */
function extractRepoName(url: string): string {
  const match = url.match(/repos\/([^\/]+\/[^\/]+)/);
  return match ? match[1] : 'unknown';
}

/**
 * Extract severity from issue labels
 */
function extractSeverityFromLabels(labels: any[]): string | undefined {
  const severityLabels = ['critical', 'high', 'medium', 'low'];

  for (const label of labels) {
    const name = label.name?.toLowerCase() || '';
    for (const severity of severityLabels) {
      if (name.includes(severity)) {
        return severity;
      }
    }
  }

  return undefined;
}

/**
 * Default GitHub vulnerability keywords
 */
export const DEFAULT_GITHUB_KEYWORDS = [
  'security vulnerability',
  'CVE',
  'exploit',
  'security fix',
  'security patch',
  'vulnerability report',
  'security advisory',
  'XSS',
  'SQL injection',
  'RCE',
  'authentication bypass',
];
