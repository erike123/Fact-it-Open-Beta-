/**
 * Twitter/X API Monitor
 * Searches for vulnerability disclosures in real-time using Twitter API v2
 */

export interface TwitterConfig {
  bearerToken: string;
  keywords: string[];
  maxResults?: number;
}

export interface TweetResult {
  id: string;
  text: string;
  author: string;
  authorId: string;
  createdAt: string;
  url: string;
  metrics: {
    likes: number;
    retweets: number;
    replies: number;
  };
  urls?: string[];
  githubUrls?: string[];
}

/**
 * Monitor Twitter for vulnerability keywords
 */
export async function monitorTwitter(config: TwitterConfig): Promise<TweetResult[]> {
  if (!config.bearerToken) {
    console.warn('[Twitter Monitor] No bearer token provided, skipping');
    return [];
  }

  console.info('[Twitter Monitor] Searching Twitter for vulnerabilities...');

  const query = buildSearchQuery(config.keywords);
  const tweets: TweetResult[] = [];

  try {
    const response = await fetch(
      `https://api.twitter.com/2/tweets/search/recent?${new URLSearchParams({
        query,
        max_results: String(config.maxResults || 50),
        'tweet.fields': 'created_at,author_id,public_metrics,entities',
        expansions: 'author_id',
        'user.fields': 'username',
      })}`,
      {
        headers: {
          Authorization: `Bearer ${config.bearerToken}`,
        },
      }
    );

    if (!response.ok) {
      console.error('[Twitter Monitor] API error:', response.status, await response.text());
      return [];
    }

    const data = await response.json();

    if (!data.data || data.data.length === 0) {
      console.info('[Twitter Monitor] No tweets found');
      return [];
    }

    // Parse tweets
    for (const tweet of data.data) {
      const author = data.includes?.users?.find((u: any) => u.id === tweet.author_id);

      const urls = extractUrls(tweet.text);
      const githubUrls = urls.filter((url) => url.includes('github.com'));

      tweets.push({
        id: tweet.id,
        text: tweet.text,
        author: author?.username || 'unknown',
        authorId: tweet.author_id,
        createdAt: tweet.created_at,
        url: `https://twitter.com/${author?.username}/status/${tweet.id}`,
        metrics: {
          likes: tweet.public_metrics?.like_count || 0,
          retweets: tweet.public_metrics?.retweet_count || 0,
          replies: tweet.public_metrics?.reply_count || 0,
        },
        urls,
        githubUrls,
      });
    }

    console.info(`[Twitter Monitor] Found ${tweets.length} tweets`);
    return tweets;
  } catch (error) {
    console.error('[Twitter Monitor] Error:', error);
    return [];
  }
}

/**
 * Build Twitter search query from keywords
 */
function buildSearchQuery(keywords: string[]): string {
  // Combine keywords with OR, exclude retweets
  const keywordQuery = keywords.map((kw) => `"${kw}"`).join(' OR ');
  return `(${keywordQuery}) -is:retweet lang:en`;
}

/**
 * Extract URLs from tweet text
 */
function extractUrls(text: string): string[] {
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  return text.match(urlRegex) || [];
}

/**
 * Default vulnerability keywords
 */
export const DEFAULT_VULN_KEYWORDS = [
  'vulnerability discovered',
  'security vulnerability',
  'CVE-202',
  'zero-day',
  'exploit released',
  'smart contract vulnerability',
  'critical security bug',
  'bug bounty',
  'responsible disclosure',
  'RCE vulnerability',
  'authentication bypass',
  'SQL injection',
  'XSS vulnerability',
  'SSRF exploit',
  'reentrancy attack',
  'integer overflow',
  'access control bypass',
];
