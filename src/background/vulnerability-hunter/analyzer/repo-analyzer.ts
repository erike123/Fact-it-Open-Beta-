/**
 * GitHub Repository Analyzer
 * Fetches and analyzes repository information, documentation, and dependencies
 */

export interface RepoAnalysisResult {
  repository: string;
  cloned: boolean;
  readme: string | null;
  securityMd: string | null;
  languages: Record<string, number>;
  dependencies: Dependency[];
  vulnerableDependencies: VulnerableDependency[];
  fileTree: string[];
  linesOfCode: number;
  lastCommit: string;
  stars: number;
  topics: string[];
}

export interface Dependency {
  name: string;
  version: string;
  type: 'runtime' | 'dev';
  ecosystem: 'npm' | 'pypi' | 'cargo' | 'maven' | 'other';
}

export interface VulnerableDependency extends Dependency {
  vulnerabilities: {
    cve: string;
    severity: string;
    summary: string;
    fixedIn?: string;
  }[];
}

/**
 * Analyze a GitHub repository
 */
export async function analyzeRepository(
  repoUrl: string,
  githubToken: string
): Promise<RepoAnalysisResult | null> {
  console.info(`[Repo Analyzer] Analyzing ${repoUrl}`);

  const repoInfo = parseGitHubUrl(repoUrl);
  if (!repoInfo) {
    console.error('[Repo Analyzer] Invalid GitHub URL');
    return null;
  }

  try {
    // Fetch repository metadata
    const repoData = await fetchRepositoryData(repoInfo.owner, repoInfo.repo, githubToken);
    if (!repoData) return null;

    // Fetch README
    const readme = await fetchFileContent(repoInfo.owner, repoInfo.repo, 'README.md', githubToken);

    // Fetch SECURITY.md
    const securityMd = await fetchFileContent(
      repoInfo.owner,
      repoInfo.repo,
      'SECURITY.md',
      githubToken
    );

    // Fetch languages
    const languages = await fetchLanguages(repoInfo.owner, repoInfo.repo, githubToken);

    // Fetch file tree (limited)
    const fileTree = await fetchFileTree(repoInfo.owner, repoInfo.repo, githubToken);

    // Analyze dependencies based on detected ecosystem
    const dependencies = await analyzeDependencies(repoInfo.owner, repoInfo.repo, githubToken);

    // Check for known vulnerable dependencies
    const vulnerableDependencies = await checkVulnerableDependencies(dependencies);

    const result: RepoAnalysisResult = {
      repository: repoUrl,
      cloned: false, // We're using GitHub API, not cloning
      readme,
      securityMd,
      languages,
      dependencies,
      vulnerableDependencies,
      fileTree,
      linesOfCode: repoData.size * 10, // Rough estimate
      lastCommit: repoData.pushed_at,
      stars: repoData.stargazers_count,
      topics: repoData.topics || [],
    };

    console.info(
      `[Repo Analyzer] Analysis complete: ${dependencies.length} dependencies, ${vulnerableDependencies.length} vulnerable`
    );

    return result;
  } catch (error) {
    console.error('[Repo Analyzer] Error:', error);
    return null;
  }
}

/**
 * Parse GitHub URL to extract owner and repo
 */
function parseGitHubUrl(url: string): { owner: string; repo: string } | null {
  const match = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
  if (!match) return null;

  return {
    owner: match[1],
    repo: match[2].replace(/\.git$/, ''),
  };
}

/**
 * Fetch repository metadata
 */
async function fetchRepositoryData(
  owner: string,
  repo: string,
  token: string
): Promise<any | null> {
  try {
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
      headers: {
        Authorization: `token ${token}`,
        Accept: 'application/vnd.github.v3+json',
      },
    });

    if (!response.ok) {
      console.error('[Repo Analyzer] Repository fetch error:', response.status);
      return null;
    }

    return await response.json();
  } catch (error) {
    console.error('[Repo Analyzer] Error fetching repository:', error);
    return null;
  }
}

/**
 * Fetch file content from repository
 */
async function fetchFileContent(
  owner: string,
  repo: string,
  path: string,
  token: string
): Promise<string | null> {
  try {
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
      {
        headers: {
          Authorization: `token ${token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      return null; // File doesn't exist
    }

    const data = await response.json();

    if (data.content) {
      // Decode base64 content
      return atob(data.content);
    }

    return null;
  } catch (error) {
    return null;
  }
}

/**
 * Fetch repository languages
 */
async function fetchLanguages(
  owner: string,
  repo: string,
  token: string
): Promise<Record<string, number>> {
  try {
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/languages`, {
      headers: {
        Authorization: `token ${token}`,
        Accept: 'application/vnd.github.v3+json',
      },
    });

    if (!response.ok) {
      return {};
    }

    const data = await response.json();

    // Convert to percentages
    const total = Object.values(data).reduce((sum: number, bytes: any) => sum + bytes, 0);
    const percentages: Record<string, number> = {};

    for (const [lang, bytes] of Object.entries(data)) {
      percentages[lang] = Math.round(((bytes as number) / total) * 100);
    }

    return percentages;
  } catch (error) {
    return {};
  }
}

/**
 * Fetch file tree (limited to root directory)
 */
async function fetchFileTree(owner: string, repo: string, token: string): Promise<string[]> {
  try {
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents`, {
      headers: {
        Authorization: `token ${token}`,
        Accept: 'application/vnd.github.v3+json',
      },
    });

    if (!response.ok) {
      return [];
    }

    const data = await response.json();
    return data.map((item: any) => item.name);
  } catch (error) {
    return [];
  }
}

/**
 * Analyze dependencies from package files
 */
async function analyzeDependencies(
  owner: string,
  repo: string,
  token: string
): Promise<Dependency[]> {
  const dependencies: Dependency[] = [];

  // Check for package.json (npm)
  const packageJson = await fetchFileContent(owner, repo, 'package.json', token);
  if (packageJson) {
    try {
      const pkg = JSON.parse(packageJson);

      if (pkg.dependencies) {
        for (const [name, version] of Object.entries(pkg.dependencies)) {
          dependencies.push({
            name,
            version: String(version),
            type: 'runtime',
            ecosystem: 'npm',
          });
        }
      }

      if (pkg.devDependencies) {
        for (const [name, version] of Object.entries(pkg.devDependencies)) {
          dependencies.push({
            name,
            version: String(version),
            type: 'dev',
            ecosystem: 'npm',
          });
        }
      }
    } catch (error) {
      console.error('[Repo Analyzer] Error parsing package.json:', error);
    }
  }

  // Check for requirements.txt (Python)
  const requirementsTxt = await fetchFileContent(owner, repo, 'requirements.txt', token);
  if (requirementsTxt) {
    const lines = requirementsTxt.split('\n');
    for (const line of lines) {
      const match = line.match(/^([a-zA-Z0-9_-]+)==([0-9.]+)/);
      if (match) {
        dependencies.push({
          name: match[1],
          version: match[2],
          type: 'runtime',
          ecosystem: 'pypi',
        });
      }
    }
  }

  // Check for Cargo.toml (Rust)
  const cargoToml = await fetchFileContent(owner, repo, 'Cargo.toml', token);
  if (cargoToml) {
    // Simple parsing (not full TOML parser)
    const depMatches = cargoToml.matchAll(/([a-zA-Z0-9_-]+)\s*=\s*"([^"]+)"/g);
    for (const match of depMatches) {
      dependencies.push({
        name: match[1],
        version: match[2],
        type: 'runtime',
        ecosystem: 'cargo',
      });
    }
  }

  return dependencies;
}

/**
 * Check dependencies for known vulnerabilities
 * In MVP, we'll use a simple heuristic. In production, use Snyk API or npm audit
 */
async function checkVulnerableDependencies(
  dependencies: Dependency[]
): Promise<VulnerableDependency[]> {
  // MVP: Just flag very old versions as potentially vulnerable
  // In production: Use Snyk API, npm audit API, or OSV.dev API

  const vulnerable: VulnerableDependency[] = [];

  // Known vulnerable patterns (simplified for MVP)
  const knownVulnerable: Record<string, { version: string; cve: string; severity: string }> = {
    lodash: { version: '4.17.19', cve: 'CVE-2020-8203', severity: 'high' },
    'minimist': { version: '1.2.5', cve: 'CVE-2021-44906', severity: 'critical' },
    'node-fetch': { version: '2.6.6', cve: 'CVE-2022-0235', severity: 'high' },
  };

  for (const dep of dependencies) {
    if (knownVulnerable[dep.name]) {
      const vuln = knownVulnerable[dep.name];
      vulnerable.push({
        ...dep,
        vulnerabilities: [
          {
            cve: vuln.cve,
            severity: vuln.severity,
            summary: `Known vulnerability in ${dep.name}@${dep.version}`,
            fixedIn: 'latest',
          },
        ],
      });
    }
  }

  return vulnerable;
}
